## Chapter 1

## Duck 시뮬레이터 게임
조는 오리 시뮬레이션 게임을 만들고 있다.     
이 시스템을 처음 디자인한 사람은 Duck이라는 슈퍼 클래스를 만들고 그를 확장해 MallardDuck,RedheadDuck 등 상속받은 클래스를 만들었다.
Duck에는 quack(),swim(),display()가 있었고 이제 fly()를 추가할려고 한다.    
그리고 상속받은 Mallard,Redhead는 Override 하여 fly()를 구현하였다.      

-> 근데 여기서 문제점이 생겼다. 날면 안되는 오리마저도 fly()를 Override하여 날아다니기 시작하였다!    
-> 물론 fly()를 override 했을 때 아무것도 안하게 하면 된다.
-> 가짜오리를 추가하기 위해서는 quack()에도 아무 소리가 안나게 해야한다.     
-> 결국 이렇게 하면 코드가 더러워진다.

### 상속의 단점
1. 서브 클래스에서 코드가 중복
2. 실행 시 특징을 바꾸기 힘들다.
3. 모든 오리의 행동을 알기 어렵다.
4. 코드를 변경했을 때 다른 오리들에게 원치 않은 영향을 끼칠 수 있다.

### 인터페이스 설계하기
조는 이제 결국 상속이 옳은 방법이 아니라는 것을 깨달았고 특정 형식의 오리만 날거나 꽥꽥거릴 수 있도록 하는 방법을 찾기로 한다.<br>
flyable,Quackable이라는 인터페이스를 만들어서 이를 구현한 객체만 override한 함수를 구현하기로 한다.<br>
-> 그러나 날아가는 동작을 조금 바꾸기 위해 Duck의 서브 클래스에서 날아다닐 수 있는 48개의 코드를 전부 고쳐야하는 건 말이 안된다.<br>
-> 또, 날 수 있는 오리 중에서도 날아다니는 방식이 서로 다를 수 있다.

#### 소프트웨어 개발 불변의 진리
모든 애플리케이션은 시간이 지남에 따라 항상 변화하고 성장해야한다.<br>
그렇지 않으면 그 애플리케이션은 죽는다.<br>

### 문제 파악하기
Flyable,Quackable 인터페이스를 사용하는 방법(날 수 있는 오리들만 Flyable을 구현하기)은 괜찮아 보였다.<br>
하지만 자바 인터페이스에는 구현된 코드가 없으므로 코드를 재사용할 수 없다.<br>
즉, 한 가지 행동을 바꿀 때마다 그 행동이 정의되어 있는 서로 다른 서브 클래스를 전부 찾아서 코드를 일일이 고쳐야 하고, 그 과정에서 버그가 생길 수 있다.
```
이 인터페이스를 구현하는 쪽(각 Duck 서브클래스)에서 직접 fly() 로직을 적어야 한다.
만약 ‘날개로 난다’라는 구현이 48개 오리 중 44종에 들어 있다면,
44개의 파일이 모두 똑같은 fly() 코드(혹은 거의 비슷한 코드)를 갖게 된다.
```
-> 바뀌는 부분은 따로 뽑아서 캡슐화하면 나중에 바뀌지 않는 부분에는 영향을 미치지 않고 그 부분만 고치거나 확장할 수 있다.

**즉, 달라지는 부분을 찾아내고, 달라지지 않는 부분과 분리한다.**

### 바뀌는 부분과 아닌 부분 분리하기
바뀌는 부분은 fly,quack이니 변화하는 부분을 2개의 클래스 집합으로 만든다. 1개는 나는 것과 관련된 부분, 하나는 꽥꽥거리는 부분이다.<br>
fly(),quack()을 Duck 클래스에서 분리하려면 2개의 메소드 모두 Duck 클래스에서 끄집어내서 각 행동을 나타낼 클래스 집합을 새로 만들어야 한다.<br>

