## Chapter 13

### 디자인 패턴 정의

패턴 : 특정 context 내에서 주어진 문제의 해결책

컨텍스트(context) : 패턴이 적용되는 상황, 반복적으로 일어날 수 있는 상황이어야만 한다.

디자인 패턴 : 어떤 context(맥락) 내에서 일련의 제약조건에 의해 영향을 받는 문제가 발생한다면, 그 제약조건 내에서 목적 달성을 위한 해결책이 되는 디자인을 적용하면 된다.

패턴을 적용시켜보기 전에 문제, 컨텍스트, 해결책을 생각해보자.

### 포스(force)
디자인 패턴의 정의에 따르면, 문제는 목적과 일련의 제약조건으로 구성된다.

어떤 이들은 이를 합쳐서 포스(force)라고 부르기도 한다.

즉, 패턴의 정의에서 포스란 해결책을 형성하고 제어하는 것이다.

다음은 정확한 포스의 정의이다.
```
포스(force)라는 개념은 소프트웨어 엔지니어들이 설계와 구현을 정당화할 때 사용하는 여러 기준들을 일반화한 것이다.
예를 들어, 컴퓨터 과학에서의 고전적인 알고리즘 연구에서는 해결해야 할 주요한 '힘'은 **효율성(시간 복잡도)**이다.
하지만 패턴은 당신이 만드는 모든 산출물의 개발 과정에서 마주치는 더 크고, 측정하기 어렵고, 서로 충돌하는 목표와 제약들을 다룬다.
예를 들면, 정확성, 자원, 구조, 구성, 사용 방식 등이 있다.
```

### 패턴 카탈로그
여러 디자인 패턴들을 체계적으로 정리하고 설명해 놓은 모음집이다.

패턴 카탈로그에는 다음과 같은 내용들이 있다.
```
이름
용도, Intent : 패턴의 역할
동기, Motivation : 어떻게 문제를 해결하는지 나와있음.
적용 대상(활용성), Applicability : 적용할 수 있는 상황
구조, Structure : 클래스들의 관계를 다이어그램으로 나타냄.
구성 요소, Participant : 객체들에 대한 설명
협력 방법, Collaborations : 각 구성 요소가 패턴 내에서 어떤 식으로 서로 도움을 주는지에 대한 설명
결과, Consequences 
구현, Implementation : 필요한 기술, 주의사항
샘플 코드, Sample Code : 예시 코드
잘 알려진 사용 예, Known uses
관련 패턴, Related Patterns : 이 패턴과 밀접하게 관련된 다른 패턴들과 이들의 중요한 차이점 등
```

대표적인 예시

**『Gang of Four (GoF) 디자인 패턴 책』**에서 소개된 패턴 카탈로그는 가장 유명한 예이다.

총 23가지 디자인 패턴을 소개하고 3가지 범주로 분류한다.

1. 생성 패턴(Creational) – 객체 생성 관련
2. 구조 패턴(Structural) – 클래스/객체 구성
3. 행위 패턴(Behavioral) – 객체 간 상호작용

### 생성 패턴
객체 인스턴스를 생성하는 패턴이다.

클라이언트와 그 클라이언트가 생성해야 하는 객체 인스턴스 사이의 연결을 끊어준다.
기존 코드의 유연성과 재사용을 증가시키는 다양한 객체 생성 매커니즘들을 제공한다.

1. 팩토리 메서드(Factory Method) 패턴
서브클래스에서 생성할 구상 클래스를 결정한다.

즉, 부모 클래스에서 객체들을 생성할 수 있는 인터페이스를 제공하지만 자식 클래스들이 생성될 객체들의 유형을 변경할 수 있도록 한다.

2. 추상 팩토리(Abstract Factory) 패턴
클라이언트에서 구상 클래스를 지정하지 않으면서도 객체군(관련 객체들의 모음)을 생성할 수 있도록 해준다.


3. 빌더(Builder) 패턴
복잡한 객체들을 단계별로 생성할 수 있도록 해준다.

이 패턴을 통해 같은 제작 코드로 객체의 다양한 유형들과 표현을 제작할 수 있게 된다.

4. 프로토타입(Prototype) 패턴
코드를 그들의 클래스들에 의존시키지 않고 기존 객체들을 복사할 수 있도록 한다.

5. 싱글턴(Singleton) 패턴
클래스에 인스턴스가 하나만 있도록 하면서 이 인스턴스에 대한 전역 접근(액세스) 지점을 제공한다.

### 행동 패턴
클래스와 객체들이 상호작용하는 방법과 역할을 분담하는 방법을 다루는 패턴

알고리즘들 및 객체 간의 책임 할당과 관련이 있다.

1. 책임 연쇄(Chain of Responsibility) 패턴
핸들러들의 체인(사슬)을 따라 요청을 전달할 수 있게 해준다.

각 핸들러는 요청을 받으면 요청을 처리할지 아니면 체인의 다음 핸들러로 전달할지를 결정한다.

2. 커맨드(Command) 패턴
요청을 요청에 대한 모든 정보가 포함된 독립실행형 객체로 변환한다.

이 변환은 다양한 요청들이 있는 메서드들을 인수화 할 수 있도록 하며,
요청의 실행을 지연 또는 대기열에 넣을 수 있도록 하고, 또 실행 취소할 수 있는 작업을 지원할 수 있도록 한다.

3. 인터프리터(Interpreter) 패턴
어떤 언어의 대해, 그 언어의 문법에 대한 표현을 정의하면서 그 표현을 사용하여 해당 언어로 기술된 문장을 해석하는 해석자를 함께 정의한다.

4. 반복자(Iterator) 패턴
컬렉션이 어떤 식으로 구현되었는지(리스트, 스택, 트리 등) 드러내지 않으면서도
컬렉션 내에 있는 모든 객체를 하나씩 순회하여 반복 작업을 처리할 수 있게 해준다.

5. 중재자(Mediator) 패턴
객체 간의 직접 통신을 제한하고 중재자 객체를 통해서만 협력하도록 한다.

따라서 이 패턴을 통해 객체 간의 혼란스러운 의존 관계들을 줄일 수 있다.

6. 메멘토(Memento) 패턴
객체의 구현 세부 사항을 공개하지 않으면서 해당 객체의 이전 상태를 저장하고 복원할 수 있게 해준다.

7. 옵저버(Observer) 패턴
여러 객체에 자신이 관찰 중인 객체에 발생하는 모든 이벤트에 대하여 알리는 구독 메커니즘을 정의할 수 있도록 한다.

8. 상태(State) 패턴
상태를 기반으로 하는 행동을 캡슐화한 다음 위임으로 필요한 행동을 선택한다.

즉, 객체의 내부 상태가 변경될 때 해당 객체가 그의 행동을 변경할 수 있도록 하기에
객체가 행동을 변경할 때 객체가 클래스를 변경한 것처럼 보일 수 있다.

9. 전략(Strategy) 패턴
교환 가능한 행동을 캡슐화하고 위임으로 어떤 행동을 사용할지 결정한다.

즉, 알고리즘들의 패밀리를 정의하고, 각 패밀리를 별도의 클래스에 넣은 후 그들의 객체들을 상호교환할 수 있도록 한다.

10. 템플릿 메서드(Template Method) 패턴
서브클래스에서 생성할 구상 클래스를 결정한다.

부모 클래스에서 알고리즘의 골격을 정의하지만,
해당 알고리즘의 구조를 변경하지 않고 자식 클래스들이 알고리즘의 특정 단계들을 오버라이드(재정의)할 수 있도록 한다.

11. 비지터(Visitor) 패턴
알고리즘들을 그들이 작동하는 객체들로부터 분리할 수 있도록 한다.

### 구조 패턴
클래스와 객체들의 구조를 유연하고 효율적으로 유지하면서 더 큰 구조로 만들 수 있게 구상을 사용하는 패턴

클래스와 객체가 새로운 구조와 기능을 만들려고 클래스와 객체를 구성하는 방법들이다.

1. 어댑터(Adapter) 패턴
객체를 감싸서 다른 인터페이스를 제공하는 것을 통해 호환되지 않는 인터페이스를 가진 객체들이 협업할 수 있도록 한다.

2. 브리지(Bridge) 패턴
큰 클래스 또는 밀접하게 관련된 클래스들의 집합을 두 개의 개별 계층구조(추상화 및 구현)로 나눈 후 각각 독립적으로 개발할 수 있도록 한다.

3. 복합체(Composite) 패턴
객체들을 트리 구조들로 구성한 후, 클라이언트에서 객체 컬렉션과 개별 객체를 똑같이 다룰 수 있도록 한다.

4. 데코레이터(Decorator) 패턴
객체를 특수 래퍼(wrapper) 객체들로 감싸서 새로운 행동을 제공한다.

5. 퍼사드(Facade) 패턴
라이브러리, 프레임워크 또는 다른 일련의 클래스들에 대한 단순화된 인터페이스를 제공한다.

6. 플라이웨이트(Flyweight) 패턴
각 객체에 모든 데이터를 유지하는 대신,
여러 객체들 간에 상태의 공통 부분들을 공유하여 사용할 수 있는 RAM에 더 많은 객체들을 포함할 수 있도록 한다.

7. 프록시(Proxy) 패턴
객체를 감싸서 그 객체로의 접근을 제어한다.

다른 객체에 대한 대체 또는 자리표시자를 제공할 수 있으며,
클라이언트의 요청이 원래 객체에 전달되기 전 또는 후에 무언가를 수행할 수 있도록 한다.

### 패턴으로 생각하기
패턴으로 생각한다는 것은 어떤 디자인을 봤을 때 패턴 적용 여부를 결정할 수 있는 안목을 가졌다는 것이다.

디자인 패턴은 필요할 때만 써야 하는 도구에 불과하다.

어떤 디자인이든 될 수 있으면 단순하게 만들어야 한다.

따라서 디자인 원칙들을 바탕으로 제 할 일을 완수할 수 있는 가장 간단한 코드를 만들다가,
패턴이 꼭 필요한 상황(확장성이 필요한 경우)이 닥쳤을 때에만 디자인 패턴을 사용하여 조금 복잡하게 만드는 것이 좋다.

실질적인 확장성만을 추구해야 한다.

또한, 객체지향 원칙들을 종합적으로 고려하여 패턴이 필요한 상황이 왔을 때 패턴을 필요에 따라 적절히 변형해서 적용할 수도 있어야 한다.

다음은 패턴으로 생각하는 데 있어서 도움이 될 만한 내용들이다.


#### 최대한 단순하게
디자인을 할 때 가장 중요한 원칙은 최대한 단순한 방법(KISS, Keep it Simple)으로 문제를 해결하기이다.

“이 문제에 어떻게 패턴을 적용할 수 있을까?”가 아닌, “어떻게 하면 단순하게 해결할 수 있을까?”에 초점을 맞춰야 한다.

가장 단순하고 유연한 디자인을 만들 때 패턴이 있어야 한다면 그때 패턴을 적용하면 된다.


#### 디자인 패턴은 만병통치약이 아니다
패턴은 반복적으로 발생하는 문제의 일반적인 해결책이며, 수많은 개발자가 오랫동안 검증한 해결책이다.

하지만 패턴을 사용할 때는 그 패턴이 우리가 설계한 디자인에 미칠 영향과 결과를 주의 깊게 생각해봐야 한다.

#### 패턴이 필요할 때
어떤 경우에 패턴을 써야할까?

디자인을 할 때, 지금 디자인상의 문제에 적합하다는 확신이 든다면 패턴을 도입해야 한다.

1. 간단한 해결책만으로는 부족하다고 확신을 가지면 해결해야 할 문제와 제약조건을 종합적으로 고려해 봐야 한다.

만약 어떤 패턴을 써야 할지 잘 모르겠다면 문제 해결에 도움이 될 만한 패턴이 있는지를 훑어봐야 한다.

이때 패턴 카탈로그의 용도와 적용 대상 섹션을 살펴보면 좋다.

괜찮은 패턴을 찾았다면 패턴 카탈로그의 결과 섹션을 보고 디자인의 나머지 부분에 미치는 영향이 어느 정도인지 확인해 보아야 한다.


2. 간단한 해결책으로 문제가 해결되는 데도 시스템의 어떤 부분이 변경될 거라고 예측되는 상황에는 디자인 패턴을 적용해야 한다.

디자인에서 변경될 수 있는 부분이 있다면(발생 가능성이 높은 실질적인 변경) 패턴을 적용할 여지가 있다.

하지만 발생 가능성이 그리 높지 않은 가상적인 변경에 대비해서 패턴을 적용하는 일은 바람직하지 않다.


#### 리팩터링과 패턴
리팩터링의 목적은 행동 변경이 아니라 구조 개선에 있다.

따라서 리팩터링은 패턴을 사용하면 구조가 더 개선될 수 있을지 검토해볼 수 있는 아주 좋은 기회이다.


#### 꼭 필요하지 않은 패턴은 빼자
시스템이 점점 복잡해지면서 처음에 기대했던 유연성이 전혀 발휘되지 못한다면 패턴을 과감하게 제거해 버리는 것이 낫다.

즉, 패턴보다 간단한 해결책이 더 나을 것 같다 싶을 때 패턴을 제거하면 된다.


#### 꼭 필요하지 않은 패턴을 미리 적용할 필요는 없다
지금 당장 변화에 대처하는 디자인을 만들어야 한다면 패턴을 적용해서 그 변화에 적응해야 하지만,
꼭 필요하지 않은데도 괜히 패턴을 추가하는 일은 피해야 한다.

패턴을 쓰다 보면 시스템이 더 복잡해지는 경향이 있으며, 나중에 그 패턴을 사용하지 않을 수도 있기 때문이다.

### 안티 패턴
안티 패턴은 어떤 문제의 나쁜 해결책에 이르는 길을 알려준다.

안티 패턴은 좋은 해결책처럼 보이지만 적용하고 나서야 나중에 좋지 않은 해결책이었다는 것을 알게 된다.

안티 패턴을 문서로 정리해 두면 다른 사람들이 나쁜 해결책을 구현하기 전에 미리 파악할 수 있다.

